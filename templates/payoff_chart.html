{% extends "base.html" %}

{% block title %}Payoff Chart - Multi-Leg Options{% endblock %}

{% block content %}
<div class="container-fluid">
  <div class="row">
    <!-- Left Column: Option Chain with Buy/Sell Buttons -->
    <div class="col-md-4 mb-4">
      <div class="card">
        <div class="card-header">
          <h5 class="card-title mb-0">
            <i class="fas fa-chart-line me-2"></i>Option Chain
          </h5>
        </div>
        <div class="card-body p-0">
          <!-- Symbol and Expiry Selection -->
          <div class="p-3 border-bottom">
            <div class="row g-2">
              <div class="col-md-6">
                <select id="symbolSelect" class="form-select form-select-sm">
                  <option value="">Select Symbol</option>
                  <option value="NIFTY 50">NIFTY 50</option>
                  <option value="BANKNIFTY">BANKNIFTY</option>
                  <option value="FINNIFTY">FINNIFTY</option>
                </select>
              </div>
              <div class="col-md-6">
                <select id="expirySelect" class="form-select form-select-sm">
                  <option value="">Select Expiry</option>
                </select>
              </div>
            </div>
          </div>
          
          <!-- Scrollable Option Chain Container -->
          <div id="optionChainContainer" style="max-height: 60vh; overflow-y: auto;">
            <table class="table table-sm table-hover mb-0" id="optionChainTable">
              <thead class="table-light sticky-top">
                <tr class="text-center">
                  <th style="width: 15%;">Call B/S</th>
                  <th style="width: 15%;">Call LTP</th>
                  <th style="width: 15%;">Strike</th>
                  <th style="width: 15%;">Put LTP</th>
                  <th style="width: 15%;">Put B/S</th>
                </tr>
              </thead>
              <tbody id="optionTableBody">
                <!-- Dynamic content will be inserted here -->
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <!-- Right Column: Payoff Chart and Position Management -->
    <div class="col-md-8">
      <!-- Margin Info Card -->
      <div class="card mb-3">
        <div class="card-header">
          <h5 class="card-title mb-0">
            <i class="fas fa-calculator me-2"></i>Margin & P&L Info
          </h5>
        </div>
        <div class="card-body">
          <div id="marginInfo" class="d-flex flex-wrap justify-content-around text-center">
            <!-- Margin info will be populated here -->
          </div>
        </div>
      </div>

      <!-- Payoff Chart Card -->
      <div class="card mb-3">
        <div class="card-header">
          <h5 class="card-title mb-0">
            <i class="fas fa-chart-area me-2"></i>Multi-Leg Payoff Chart
          </h5>
        </div>
        <div class="card-body">
          <div id="chartContainer" style="width: 100%; height: 400px;"></div>
        </div>
      </div>

      <!-- Current Position Card -->
      <div class="card">
        <div class="card-header d-flex justify-content-between align-items-center">
          <h5 class="card-title mb-0">
            <i class="fas fa-list me-2"></i>Current Position
          </h5>
          <div class="btn-group btn-group-sm" role="group">
            <button id="saveBtn" class="btn btn-outline-success" title="Save Current Position">
              <i class="fas fa-save"></i>
            </button>
            <button id="clearBtn" class="btn btn-outline-danger" title="Clear All Position">
              <i class="fas fa-trash"></i>
            </button>
          </div>
        </div>
        <div class="card-body p-0">
          <div style="max-height: 300px; overflow-y: auto;">
            <table class="table table-sm table-striped mb-0">
              <thead class="table-light sticky-top">
                <tr class="text-center">
                  <th>Action</th>
                  <th>Strike</th>
                  <th>Expiry</th>
                  <th>Entry Price</th>
                  <th>Lot Size</th>
                  <th>Lots</th>
                  <th>Qty</th>
                  <th>Count</th>
                  <th>Remove</th>
                </tr>
              </thead>
              <tbody id="countsTableBody">
                <!-- User B/S selections will be recorded here -->
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
/* Buy/Sell Button Styles */
.option_button {
  display: none;
  align-items: center;
  justify-content: center;
  position: relative;
  padding: 0 8px;
  height: 24px;
  font-size: 11px;
  border: 1px solid;
  border-radius: 3px;
  background: #fff;
  cursor: pointer;
  margin: 0 2px;
  transition: all 0.2s ease;
}

.option_button:hover {
  box-shadow: 0 0 5px rgba(0,0,0,0.3);
  transform: translateY(-1px);
}

.option_button.active {
  display: inline-flex !important;
}

.buy_sell_cell {
  position: relative;
  vertical-align: middle !important;
  padding: 0.5rem !important;
  text-align: center;
}

.buy_sell_cell:hover .option_button {
  display: inline-flex;
}

.buy_button {
  color: #198754;
  border-color: #198754;
}

.buy_button:hover {
  background-color: #198754;
  color: white;
}

.sell_button {
  color: #dc3545;
  border-color: #dc3545;
}

.sell_button:hover {
  background-color: #dc3545;
  color: white;
}

/* Count Badge */
.count_badge {
  display: none;
  position: absolute;
  top: -6px;
  right: -6px;
  width: 16px;
  height: 16px;
  line-height: 16px;
  text-align: center;
  font-size: 10px;
  color: #fff;
  border-radius: 50%;
  font-weight: bold;
}

.buy_button .count_badge {
  background: #198754;
}

.sell_button .count_badge {
  background: #dc3545;
}

/* Dropdown Menu */
.dropdown_menu {
  display: none;
  position: absolute;
  top: calc(100% + 4px);
  left: 0;
  background: #fff;
  border: 1px solid #dee2e6;
  border-radius: 4px;
  min-width: 80px;
  z-index: 9999;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}

.dropdown_menu button {
  display: block;
  width: 100%;
  padding: 6px 12px;
  background: none;
  border: none;
  text-align: left;
  cursor: pointer;
  font-size: 11px;
  transition: background-color 0.2s;
}

.dropdown_menu button:hover {
  background: #f8f9fa;
}

/* Margin Metrics */
.metric {
  margin: 0.5rem;
  text-align: center;
  min-width: 120px;
}

.metric-label {
  font-size: 12px;
  color: #6c757d;
  margin-bottom: 4px;
  font-weight: 500;
}

.metric-value {
  font-size: 16px;
  font-weight: bold;
}

/* ITM Highlighting */
.itm-highlight {
  background-color: #fff3cd !important;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .option_button {
    height: 20px;
    font-size: 10px;
    padding: 0 6px;
  }
  
  .count_badge {
    width: 14px;
    height: 14px;
    line-height: 14px;
    font-size: 9px;
  }
}
</style>

<script src="https://code.highcharts.com/highcharts.js"></script>
<script>
// Global variables
const defaultLotSize = 75;
const defaultLot = 1;
let counters = [];
let firstClickFlags = [];
let payoffChart = null;
let currentSymbol = '';
let currentExpiry = '';
let spotPrice = 0;

// Sample option chain data - replace with real data from your backend
const sampleOptionData = [
  { strike: 22100, callLtp: 855.1, putLtp: 3.9, expiry: "27 Jan" },
  { strike: 22150, callLtp: 820.5, putLtp: 4.7, expiry: "27 Jan" },
  { strike: 22200, callLtp: 786.2, putLtp: 5.7, expiry: "27 Jan" },
  { strike: 22250, callLtp: 752.8, putLtp: 7.0, expiry: "27 Jan" },
  { strike: 22300, callLtp: 661.8, putLtp: 8.8, expiry: "27 Jan" },
  { strike: 22350, callLtp: 607.3, putLtp: 11.2, expiry: "27 Jan" },
  { strike: 22400, callLtp: 560.0, putLtp: 14.4, expiry: "27 Jan" },
  { strike: 22450, callLtp: 514.5, putLtp: 17.4, expiry: "27 Jan" },
  { strike: 22500, callLtp: 471.0, putLtp: 21.9, expiry: "27 Jan" },
  { strike: 22550, callLtp: 426.9, putLtp: 27.7, expiry: "27 Jan" },
  { strike: 22600, callLtp: 382.7, putLtp: 34.5, expiry: "27 Jan" },
  { strike: 22650, callLtp: 340.8, putLtp: 43.4, expiry: "27 Jan" },
  { strike: 22700, callLtp: 299.1, putLtp: 52.9, expiry: "27 Jan" },
  { strike: 22750, callLtp: 263.4, putLtp: 65.3, expiry: "27 Jan" },
  { strike: 22800, callLtp: 228.7, putLtp: 79.3, expiry: "27 Jan" },
  { strike: 22850, callLtp: 195.8, putLtp: 97.7, expiry: "27 Jan" },
  { strike: 22900, callLtp: 165.8, putLtp: 117.5, expiry: "27 Jan" },
  { strike: 22950, callLtp: 139.4, putLtp: 140.1, expiry: "27 Jan" },
  { strike: 23000, callLtp: 114.2, putLtp: 168.1, expiry: "27 Jan" },
  { strike: 23050, callLtp: 94.2, putLtp: 194.5, expiry: "27 Jan" },
  { strike: 23100, callLtp: 76.5, putLtp: 227.2, expiry: "27 Jan" },
  { strike: 23150, callLtp: 61.7, putLtp: 261.9, expiry: "27 Jan" },
  { strike: 23200, callLtp: 50.0, putLtp: 300.5, expiry: "27 Jan" },
  { strike: 23250, callLtp: 40.5, putLtp: 343.2, expiry: "27 Jan" },
  { strike: 23300, callLtp: 31.9, putLtp: 386.4, expiry: "27 Jan" }
];

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
  initializePayoffChart();
  loadSampleData();
  updateSavedTablesCombobox();
  setupEventListeners();
});

// Setup event listeners
function setupEventListeners() {
  document.getElementById('symbolSelect').addEventListener('change', handleSymbolChange);
  document.getElementById('expirySelect').addEventListener('change', handleExpiryChange);
  document.getElementById('saveBtn').addEventListener('click', saveCurrentPositions);
  document.getElementById('clearBtn').addEventListener('click', clearAllPositions);
  
  // Close dropdowns when clicking outside
  document.addEventListener('click', closeAllDropdowns);
}

// Load sample data for demo
function loadSampleData() {
  currentSymbol = 'NIFTY 50';
  currentExpiry = '27 Jan';
  spotPrice = 22950;
  
  // Populate expiry dropdown
  const expirySelect = document.getElementById('expirySelect');
  expirySelect.innerHTML = '<option value="27 Jan">27 Jan</option>';
  expirySelect.value = '27 Jan';
  
  buildOptionChainTable(sampleOptionData);
}

// Build option chain table with buy/sell buttons
function buildOptionChainTable(data) {
  const tableBody = document.getElementById('optionTableBody');
  tableBody.innerHTML = '';
  
  data.forEach((row, rowIndex) => {
    counters[rowIndex] = { ceBuy: 0, ceSell: 0, peBuy: 0, peSell: 0 };
    firstClickFlags[rowIndex] = { ceBuy: true, ceSell: true, peBuy: true, peSell: true };

    const tr = document.createElement('tr');
    
    // Determine if ITM
    const isCallITM = spotPrice > row.strike;
    const isPutITM = spotPrice < row.strike;
    
    if (isCallITM || isPutITM) {
      tr.classList.add('itm-highlight');
    }

    // Call B/S
    const callCell = document.createElement('td');
    callCell.className = 'buy_sell_cell';
    callCell.appendChild(createButton(rowIndex, 'ceBuy', 'B', 'buy_button'));
    callCell.appendChild(createButton(rowIndex, 'ceSell', 'S', 'sell_button'));

    // Call LTP
    const callLtpCell = document.createElement('td');
    callLtpCell.className = 'text-center';
    callLtpCell.textContent = row.callLtp || '';

    // Strike
    const strikeCell = document.createElement('td');
    strikeCell.className = 'text-center fw-bold';
    strikeCell.textContent = row.strike;

    // Put LTP
    const putLtpCell = document.createElement('td');
    putLtpCell.className = 'text-center';
    putLtpCell.textContent = row.putLtp || '';

    // Put B/S
    const putCell = document.createElement('td');
    putCell.className = 'buy_sell_cell';
    putCell.appendChild(createButton(rowIndex, 'peBuy', 'B', 'buy_button'));
    putCell.appendChild(createButton(rowIndex, 'peSell', 'S', 'sell_button'));

    tr.appendChild(callCell);
    tr.appendChild(callLtpCell);
    tr.appendChild(strikeCell);
    tr.appendChild(putLtpCell);
    tr.appendChild(putCell);

    tableBody.appendChild(tr);
  });
}

// Create buy/sell buttons
function createButton(rowIndex, key, label, extraClass) {
  const div = document.createElement('div');
  div.className = `option_button ${extraClass}`;
  div.id = `${key}Btn_${rowIndex}`;
  div.textContent = label + ' ';

  // Count badge
  const badge = document.createElement('span');
  badge.className = 'count_badge';
  badge.id = `${key}Badge_${rowIndex}`;
  badge.textContent = '0';
  div.appendChild(badge);

  // Dropdown menu
  const dropdown = document.createElement('div');
  dropdown.className = 'dropdown_menu';
  dropdown.id = `${key}Menu_${rowIndex}`;
  
  const addBtn = document.createElement('button');
  addBtn.textContent = '+ Add';
  addBtn.onclick = (e) => increment(rowIndex, key, e);
  
  const removeBtn = document.createElement('button');
  removeBtn.textContent = '× Remove';
  removeBtn.onclick = (e) => removeCount(rowIndex, key, e);

  dropdown.appendChild(addBtn);
  dropdown.appendChild(removeBtn);
  div.appendChild(dropdown);

  // Main click handler
  div.onclick = (e) => onButtonClick(e, rowIndex, key);
  return div;
}

// Button click handler
function onButtonClick(e, rowIndex, key) {
  e.stopPropagation();
  if (firstClickFlags[rowIndex][key]) {
    increment(rowIndex, key, e);
    firstClickFlags[rowIndex][key] = false;
  } else {
    toggleDropdown(rowIndex, key);
  }
}

// Increment position
function increment(rowIndex, key, e) {
  e.stopPropagation();
  counters[rowIndex][key]++;
  updateUI(rowIndex, key);
  hideDropdown(rowIndex, key);
  logAction(rowIndex, key, true);
  updatePayoffChartAndMargin();
}

// Remove position
function removeCount(rowIndex, key, e) {
  e.stopPropagation();
  if (counters[rowIndex][key] > 0) {
    counters[rowIndex][key]--;
    updateUI(rowIndex, key);
    if (counters[rowIndex][key] === 0) {
      firstClickFlags[rowIndex][key] = true;
    }
    hideDropdown(rowIndex, key);
    logAction(rowIndex, key, false);
    updatePayoffChartAndMargin();
  }
}

// Update UI elements
function updateUI(rowIndex, key) {
  const badgeEl = document.getElementById(`${key}Badge_${rowIndex}`);
  const val = counters[rowIndex][key];
  badgeEl.textContent = val;
  badgeEl.style.display = val > 0 ? 'block' : 'none';

  const btnEl = document.getElementById(`${key}Btn_${rowIndex}`);
  if (val > 0) btnEl.classList.add('active');
  else btnEl.classList.remove('active');
}

// Log action in positions table
function logAction(rowIndex, key, isAdd) {
  const logsBody = document.getElementById('countsTableBody');
  const rowObj = sampleOptionData[rowIndex];
  const countVal = counters[rowIndex][key];

  // Get entry price
  let entryPrice = key.startsWith('ce') ? rowObj.callLtp : rowObj.putLtp;
  let numericEntry = parseFloat(entryPrice) || 0;

  if (isAdd) {
    if (!document.getElementById(`row_${rowIndex}_${key}`)) {
      const newRow = document.createElement('tr');
      newRow.id = `row_${rowIndex}_${key}`;

      const actionText = key === 'ceBuy' ? 'CE Buy' :
                        key === 'ceSell' ? 'CE Sell' :
                        key === 'peBuy' ? 'PE Buy' : 'PE Sell';

      newRow.innerHTML = `
        <td class="text-center">${actionText}</td>
        <td class="text-center">${rowObj.strike}</td>
        <td class="text-center">${rowObj.expiry}</td>
        <td class="text-center">${numericEntry.toFixed(2)}</td>
        <td class="text-center">${defaultLotSize}</td>
        <td class="text-center">${defaultLot}</td>
        <td class="text-center">${countVal * defaultLotSize * defaultLot}</td>
        <td class="text-center" id="countCell_${rowIndex}_${key}">${countVal}</td>
        <td class="text-center">
          <button class="btn btn-sm btn-outline-danger" onclick="removePosition('${rowIndex}', '${key}')">
            <i class="fas fa-times"></i>
          </button>
        </td>
      `;
      logsBody.appendChild(newRow);
    } else {
      // Update existing row
      const existingRow = document.getElementById(`row_${rowIndex}_${key}`);
      const countCell = document.getElementById(`countCell_${rowIndex}_${key}`);
      if (countCell) countCell.textContent = countVal;

      const qtyCell = existingRow.children[6];
      if (qtyCell) qtyCell.textContent = countVal * defaultLotSize * defaultLot;
    }
  } else {
    // On remove
    const existingRow = document.getElementById(`row_${rowIndex}_${key}`);
    if (existingRow) {
      const countCell = document.getElementById(`countCell_${rowIndex}_${key}`);
      if (countCell) countCell.textContent = countVal;

      const qtyCell = existingRow.children[8];
      if (qtyCell) qtyCell.textContent = countVal * defaultLotSize * defaultLot;

      if (countVal === 0) {
        logsBody.removeChild(existingRow);
      }
    }
  }
}

// Remove position function
function removePosition(rowIndex, key) {
  const row = document.getElementById(`row_${rowIndex}_${key}`);
  if (row) {
    counters[rowIndex][key] = 0;
    firstClickFlags[rowIndex][key] = true;
    updateUI(rowIndex, key);
    row.remove();
    updatePayoffChartAndMargin();
  }
}

// Dropdown functions
function toggleDropdown(rowIndex, key) {
  closeAllDropdowns();
  const menu = document.getElementById(`${key}Menu_${rowIndex}`);
  if (menu) menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
}

function hideDropdown(rowIndex, key) {
  const menu = document.getElementById(`${key}Menu_${rowIndex}`);
  if (menu) menu.style.display = 'none';
}

function closeAllDropdowns() {
  document.querySelectorAll('.dropdown_menu').forEach(m => {
    m.style.display = 'none';
  });
}

// Initialize payoff chart
function initializePayoffChart() {
  payoffChart = Highcharts.chart('chartContainer', {
    chart: { type: 'area' },
    title: { text: 'Multi-Leg Options Payoff' },
    xAxis: { 
      title: { text: 'Underlying Price' }, 
      crosshair: true 
    },
    yAxis: { 
      title: { text: 'Net P&L (₹)' },
      plotLines: [{
        value: 0,
        color: '#666',
        width: 1,
        dashStyle: 'dash'
      }]
    },
    tooltip: { 
      valuePrefix: '₹',
      shared: true
    },
    plotOptions: {
      area: {
        marker: { enabled: false },
        zoneAxis: 'y',
        zones: [{
          value: 0,
          color: '#dc3545',
          fillColor: 'rgba(220, 53, 69, 0.1)'
        }, {
          color: '#198754',
          fillColor: 'rgba(25, 135, 84, 0.1)'
        }]
      }
    },
    series: [{
      name: 'Payoff',
      data: []
    }]
  });
}

// Update payoff chart and margin info
function updatePayoffChartAndMargin() {
  updatePayoffChart();
  updateMarginInfo();
}

// Update payoff chart
function updatePayoffChart() {
  if (!payoffChart) return;

  // Get active positions
  let legs = [];
  document.querySelectorAll('#countsTableBody tr').forEach(row => {
    const tds = row.querySelectorAll('td');
    if (tds.length >= 10) {
      const action = tds[0].textContent.trim();
      const strike = parseFloat(tds[1].textContent.trim());
      const premium = parseFloat(tds[3].textContent.trim()) || 0;
      const countVal = parseInt(tds[9].textContent.trim(), 10) || 0;
      
      if (countVal > 0) {
        legs.push({ action, strike, premium, count: countVal });
      }
    }
  });

  // Clear chart if no positions
  if (legs.length === 0) {
    payoffChart.series[0].setData([], true);
    return;
  }

  // Calculate payoff data
  const allStrikes = legs.map(leg => leg.strike);
  const minStrike = Math.min(...allStrikes) - 1000;
  const maxStrike = Math.max(...allStrikes) + 1000;
  const step = Math.max(1, Math.floor((maxStrike - minStrike) / 100));

  let payoffData = [];
  for (let S = minStrike; S <= maxStrike; S += step) {
    let total = 0;
    legs.forEach(leg => {
      total += calculateSingleOptionPayoff(leg.action, leg.strike, leg.premium, leg.count, S);
    });
    payoffData.push([S, total]);
  }

  payoffChart.series[0].setData(payoffData, true);
}

// Calculate single option payoff
function calculateSingleOptionPayoff(action, strike, premium, count, spotPrice) {
  let payoff = 0;
  
  switch (action) {
    case 'CE Buy':
      payoff = Math.max(spotPrice - strike, 0) - premium;
      break;
    case 'CE Sell':
      payoff = premium - Math.max(spotPrice - strike, 0);
      break;
    case 'PE Buy':
      payoff = Math.max(strike - spotPrice, 0) - premium;
      break;
    case 'PE Sell':
      payoff = premium - Math.max(strike - spotPrice, 0);
      break;
  }
  
  return payoff * count * defaultLotSize * defaultLot;
}

// Update margin info
function updateMarginInfo() {
  // Get active positions
  let legs = [];
  document.querySelectorAll('#countsTableBody tr').forEach(row => {
    const tds = row.querySelectorAll('td');
    if (tds.length >= 10) {
      const action = tds[0].textContent.trim();
      const strike = parseFloat(tds[1].textContent.trim());
      const premium = parseFloat(tds[3].textContent.trim()) || 0;
      const countVal = parseInt(tds[9].textContent.trim(), 10) || 0;
      
      if (countVal > 0) {
        legs.push({ action, strike, premium, count: countVal });
      }
    }
  });

  // Calculate metrics
  let totalMargin = 0;
  let netCredit = 0;
  let currentPL = 0;
  let maxProfit = 0;
  let maxLoss = 0;

  // Simple margin calculation
  legs.forEach(leg => {
    const countSize = leg.count * defaultLotSize;
    if (leg.action.endsWith('Buy')) {
      const buyMargin = leg.premium * countSize;
      totalMargin += buyMargin;
      netCredit -= buyMargin;
    } else {
      const optionProceeds = leg.premium * countSize;
      const underlyingValue = spotPrice * countSize * 0.15; // 15% of underlying
      totalMargin += optionProceeds + underlyingValue;
      netCredit += optionProceeds;
    }
    
    currentPL += calculateSingleOptionPayoff(leg.action, leg.strike, leg.premium, leg.count, spotPrice);
  });

  // Calculate max profit/loss from payoff data
  if (legs.length > 0) {
    const allStrikes = legs.map(leg => leg.strike);
    const minStrike = Math.min(...allStrikes) - 1000;
    const maxStrike = Math.max(...allStrikes) + 1000;
    const step = Math.max(1, Math.floor((maxStrike - minStrike) / 100));

    let payoffValues = [];
    for (let S = minStrike; S <= maxStrike; S += step) {
      let total = 0;
      legs.forEach(leg => {
        total += calculateSingleOptionPayoff(leg.action, leg.strike, leg.premium, leg.count, S);
      });
      payoffValues.push(total);
    }

    maxProfit = Math.max(...payoffValues);
    maxLoss = Math.min(...payoffValues);
  }

  // Update margin info display
  const marginInfoDiv = document.getElementById('marginInfo');
  marginInfoDiv.innerHTML = `
    <div class="metric">
      <div class="metric-label">Estimated Margin</div>
      <div class="metric-value" style="color: ${getColor(totalMargin)};">
        ₹${totalMargin.toFixed(2)}
      </div>
    </div>
    <div class="metric">
      <div class="metric-label">Current P&L</div>
      <div class="metric-value" style="color: ${getColor(currentPL)};">
        ₹${currentPL.toFixed(2)}
      </div>
    </div>
    <div class="metric">
      <div class="metric-label">Max Profit</div>
      <div class="metric-value" style="color: ${getColor(maxProfit)};">
        ₹${maxProfit.toFixed(2)}
      </div>
    </div>
    <div class="metric">
      <div class="metric-label">Max Loss</div>
      <div class="metric-value" style="color: ${getColor(maxLoss)};">
        ₹${maxLoss.toFixed(2)}
      </div>
    </div>
    <div class="metric">
      <div class="metric-label">Net Credit</div>
      <div class="metric-value" style="color: ${getColor(netCredit)};">
        ₹${netCredit.toFixed(2)}
      </div>
    </div>
  `;
}

// Get color for values
function getColor(val) {
  if (val < 0) return '#dc3545';
  if (val > 0) return '#198754';
  return '#6c757d';
}

// Position management functions
function addNewPosition() {
  const tableName = prompt('Enter position set name:');
  if (tableName && tableName.trim()) {
    saveCurrentPositions(tableName.trim());
  }
}

function saveCurrentPositions(tableName) {
  if (!tableName) {
    tableName = prompt('Enter name to save positions:');
  }
  if (!tableName) return;

  const tableBody = document.getElementById('countsTableBody');
  const tableHTML = tableBody.innerHTML;
  
  let savedTables = getSavedTables();
  savedTables[tableName] = tableHTML;
  setSavedTables(savedTables);
  updateSavedTablesCombobox();
  
  alert(`Positions saved as '${tableName}'`);
}

function clearAllPositions() {
  if (confirm('Clear all positions?')) {
    document.getElementById('countsTableBody').innerHTML = '';
    
    // Reset all counters and UI
    for (let i = 0; i < sampleOptionData.length; i++) {
      counters[i] = { ceBuy: 0, ceSell: 0, peBuy: 0, peSell: 0 };
      firstClickFlags[i] = { ceBuy: true, ceSell: true, peBuy: true, peSell: true };
      
      ['ceBuy', 'ceSell', 'peBuy', 'peSell'].forEach(key => {
        updateUI(i, key);
      });
    }
    
    updatePayoffChartAndMargin();
  }
}

function loadSelectedPositions() {
  const select = document.getElementById('savedTablesSelect');
  const tableName = select.value;
  if (tableName) {
    loadSavedTable(tableName);
  }
}

function deleteSelectedPositions() {
  const select = document.getElementById('savedTablesSelect');
  const tableName = select.value;
  if (tableName && confirm(`Delete saved positions '${tableName}'?`)) {
    let savedTables = getSavedTables();
    delete savedTables[tableName];
    setSavedTables(savedTables);
    updateSavedTablesCombobox();
    alert('Positions deleted');
  }
}

// Storage functions
function getSavedTables() {
  const saved = localStorage.getItem('savedPayoffTables');
  if (!saved) return {};
  try {
    return JSON.parse(saved);
  } catch (e) {
    return {};
  }
}

function setSavedTables(savedTables) {
  localStorage.setItem('savedPayoffTables', JSON.stringify(savedTables));
}

function updateSavedTablesCombobox() {
  const select = document.getElementById('savedTablesSelect');
  select.innerHTML = '<option value="">-- Select Saved Positions --</option>';
  
  const savedTables = getSavedTables();
  for (let tableName in savedTables) {
    const option = document.createElement('option');
    option.value = tableName;
    option.textContent = tableName;
    select.appendChild(option);
  }
}

function loadSavedTable(tableName) {
  const savedTables = getSavedTables();
  if (!(tableName in savedTables)) return;
  
  document.getElementById('countsTableBody').innerHTML = savedTables[tableName];
  syncOptionChainFromLogTable();
  updatePayoffChartAndMargin();
}

function syncOptionChainFromLogTable() {
  // Reset all counters
  for (let i = 0; i < sampleOptionData.length; i++) {
    counters[i] = { ceBuy: 0, ceSell: 0, peBuy: 0, peSell: 0 };
    firstClickFlags[i] = { ceBuy: true, ceSell: true, peBuy: true, peSell: true };
    ['ceBuy', 'ceSell', 'peBuy', 'peSell'].forEach(key => {
      updateUI(i, key);
    });
  }
  
  // Sync from log table
  const rows = document.querySelectorAll('#countsTableBody tr');
  rows.forEach(row => {
    const rowId = row.id;
    const parts = rowId.split('_');
    if (parts.length === 3) {
      const rowIndex = parseInt(parts[1], 10);
      const key = parts[2];
      const countCell = document.getElementById(`countCell_${rowIndex}_${key}`);
      if (countCell) {
        const countVal = parseInt(countCell.textContent, 10) || 0;
        counters[rowIndex][key] = countVal;
        firstClickFlags[rowIndex][key] = countVal === 0;
        updateUI(rowIndex, key);
      }
    }
  });
}

// Symbol and expiry change handlers
function handleSymbolChange() {
  const symbol = document.getElementById('symbolSelect').value;
  if (symbol) {
    // In real app, fetch expiry dates for this symbol
    currentSymbol = symbol;
    loadSampleData(); // For now, just reload sample data
  }
}

function handleExpiryChange() {
  const expiry = document.getElementById('expirySelect').value;
  if (expiry) {
    // In real app, fetch option chain for this expiry
    currentExpiry = expiry;
    loadSampleData(); // For now, just reload sample data
  }
}
</script>

{% endblock %}